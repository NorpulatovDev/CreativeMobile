// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'attendance_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$AttendanceEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AttendanceEventCopyWith<$Res> {
  factory $AttendanceEventCopyWith(
    AttendanceEvent value,
    $Res Function(AttendanceEvent) then,
  ) = _$AttendanceEventCopyWithImpl<$Res, AttendanceEvent>;
}

/// @nodoc
class _$AttendanceEventCopyWithImpl<$Res, $Val extends AttendanceEvent>
    implements $AttendanceEventCopyWith<$Res> {
  _$AttendanceEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AttendanceLoadGroupsImplCopyWith<$Res> {
  factory _$$AttendanceLoadGroupsImplCopyWith(
    _$AttendanceLoadGroupsImpl value,
    $Res Function(_$AttendanceLoadGroupsImpl) then,
  ) = __$$AttendanceLoadGroupsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceLoadGroupsImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceLoadGroupsImpl>
    implements _$$AttendanceLoadGroupsImplCopyWith<$Res> {
  __$$AttendanceLoadGroupsImplCopyWithImpl(
    _$AttendanceLoadGroupsImpl _value,
    $Res Function(_$AttendanceLoadGroupsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceLoadGroupsImpl implements AttendanceLoadGroups {
  const _$AttendanceLoadGroupsImpl();

  @override
  String toString() {
    return 'AttendanceEvent.loadGroups()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceLoadGroupsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return loadGroups();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return loadGroups?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (loadGroups != null) {
      return loadGroups();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return loadGroups(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return loadGroups?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (loadGroups != null) {
      return loadGroups(this);
    }
    return orElse();
  }
}

abstract class AttendanceLoadGroups implements AttendanceEvent {
  const factory AttendanceLoadGroups() = _$AttendanceLoadGroupsImpl;
}

/// @nodoc
abstract class _$$AttendanceSelectGroupImplCopyWith<$Res> {
  factory _$$AttendanceSelectGroupImplCopyWith(
    _$AttendanceSelectGroupImpl value,
    $Res Function(_$AttendanceSelectGroupImpl) then,
  ) = __$$AttendanceSelectGroupImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Group group});

  $GroupCopyWith<$Res> get group;
}

/// @nodoc
class __$$AttendanceSelectGroupImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceSelectGroupImpl>
    implements _$$AttendanceSelectGroupImplCopyWith<$Res> {
  __$$AttendanceSelectGroupImplCopyWithImpl(
    _$AttendanceSelectGroupImpl _value,
    $Res Function(_$AttendanceSelectGroupImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? group = null}) {
    return _then(
      _$AttendanceSelectGroupImpl(
        group: null == group
            ? _value.group
            : group // ignore: cast_nullable_to_non_nullable
                  as Group,
      ),
    );
  }

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GroupCopyWith<$Res> get group {
    return $GroupCopyWith<$Res>(_value.group, (value) {
      return _then(_value.copyWith(group: value));
    });
  }
}

/// @nodoc

class _$AttendanceSelectGroupImpl implements AttendanceSelectGroup {
  const _$AttendanceSelectGroupImpl({required this.group});

  @override
  final Group group;

  @override
  String toString() {
    return 'AttendanceEvent.selectGroup(group: $group)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceSelectGroupImpl &&
            (identical(other.group, group) || other.group == group));
  }

  @override
  int get hashCode => Object.hash(runtimeType, group);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceSelectGroupImplCopyWith<_$AttendanceSelectGroupImpl>
  get copyWith =>
      __$$AttendanceSelectGroupImplCopyWithImpl<_$AttendanceSelectGroupImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return selectGroup(group);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return selectGroup?.call(group);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (selectGroup != null) {
      return selectGroup(group);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return selectGroup(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return selectGroup?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (selectGroup != null) {
      return selectGroup(this);
    }
    return orElse();
  }
}

abstract class AttendanceSelectGroup implements AttendanceEvent {
  const factory AttendanceSelectGroup({required final Group group}) =
      _$AttendanceSelectGroupImpl;

  Group get group;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceSelectGroupImplCopyWith<_$AttendanceSelectGroupImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceSelectDateImplCopyWith<$Res> {
  factory _$$AttendanceSelectDateImplCopyWith(
    _$AttendanceSelectDateImpl value,
    $Res Function(_$AttendanceSelectDateImpl) then,
  ) = __$$AttendanceSelectDateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime date});
}

/// @nodoc
class __$$AttendanceSelectDateImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceSelectDateImpl>
    implements _$$AttendanceSelectDateImplCopyWith<$Res> {
  __$$AttendanceSelectDateImplCopyWithImpl(
    _$AttendanceSelectDateImpl _value,
    $Res Function(_$AttendanceSelectDateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? date = null}) {
    return _then(
      _$AttendanceSelectDateImpl(
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceSelectDateImpl implements AttendanceSelectDate {
  const _$AttendanceSelectDateImpl({required this.date});

  @override
  final DateTime date;

  @override
  String toString() {
    return 'AttendanceEvent.selectDate(date: $date)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceSelectDateImpl &&
            (identical(other.date, date) || other.date == date));
  }

  @override
  int get hashCode => Object.hash(runtimeType, date);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceSelectDateImplCopyWith<_$AttendanceSelectDateImpl>
  get copyWith =>
      __$$AttendanceSelectDateImplCopyWithImpl<_$AttendanceSelectDateImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return selectDate(date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return selectDate?.call(date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (selectDate != null) {
      return selectDate(date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return selectDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return selectDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (selectDate != null) {
      return selectDate(this);
    }
    return orElse();
  }
}

abstract class AttendanceSelectDate implements AttendanceEvent {
  const factory AttendanceSelectDate({required final DateTime date}) =
      _$AttendanceSelectDateImpl;

  DateTime get date;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceSelectDateImplCopyWith<_$AttendanceSelectDateImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceLoadForGroupAndDateImplCopyWith<$Res> {
  factory _$$AttendanceLoadForGroupAndDateImplCopyWith(
    _$AttendanceLoadForGroupAndDateImpl value,
    $Res Function(_$AttendanceLoadForGroupAndDateImpl) then,
  ) = __$$AttendanceLoadForGroupAndDateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int groupId, DateTime date});
}

/// @nodoc
class __$$AttendanceLoadForGroupAndDateImplCopyWithImpl<$Res>
    extends
        _$AttendanceEventCopyWithImpl<$Res, _$AttendanceLoadForGroupAndDateImpl>
    implements _$$AttendanceLoadForGroupAndDateImplCopyWith<$Res> {
  __$$AttendanceLoadForGroupAndDateImplCopyWithImpl(
    _$AttendanceLoadForGroupAndDateImpl _value,
    $Res Function(_$AttendanceLoadForGroupAndDateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? groupId = null, Object? date = null}) {
    return _then(
      _$AttendanceLoadForGroupAndDateImpl(
        groupId: null == groupId
            ? _value.groupId
            : groupId // ignore: cast_nullable_to_non_nullable
                  as int,
        date: null == date
            ? _value.date
            : date // ignore: cast_nullable_to_non_nullable
                  as DateTime,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceLoadForGroupAndDateImpl
    implements AttendanceLoadForGroupAndDate {
  const _$AttendanceLoadForGroupAndDateImpl({
    required this.groupId,
    required this.date,
  });

  @override
  final int groupId;
  @override
  final DateTime date;

  @override
  String toString() {
    return 'AttendanceEvent.loadForGroupAndDate(groupId: $groupId, date: $date)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceLoadForGroupAndDateImpl &&
            (identical(other.groupId, groupId) || other.groupId == groupId) &&
            (identical(other.date, date) || other.date == date));
  }

  @override
  int get hashCode => Object.hash(runtimeType, groupId, date);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceLoadForGroupAndDateImplCopyWith<
    _$AttendanceLoadForGroupAndDateImpl
  >
  get copyWith =>
      __$$AttendanceLoadForGroupAndDateImplCopyWithImpl<
        _$AttendanceLoadForGroupAndDateImpl
      >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return loadForGroupAndDate(groupId, date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return loadForGroupAndDate?.call(groupId, date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (loadForGroupAndDate != null) {
      return loadForGroupAndDate(groupId, date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return loadForGroupAndDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return loadForGroupAndDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (loadForGroupAndDate != null) {
      return loadForGroupAndDate(this);
    }
    return orElse();
  }
}

abstract class AttendanceLoadForGroupAndDate implements AttendanceEvent {
  const factory AttendanceLoadForGroupAndDate({
    required final int groupId,
    required final DateTime date,
  }) = _$AttendanceLoadForGroupAndDateImpl;

  int get groupId;
  DateTime get date;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceLoadForGroupAndDateImplCopyWith<
    _$AttendanceLoadForGroupAndDateImpl
  >
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceToggleStudentImplCopyWith<$Res> {
  factory _$$AttendanceToggleStudentImplCopyWith(
    _$AttendanceToggleStudentImpl value,
    $Res Function(_$AttendanceToggleStudentImpl) then,
  ) = __$$AttendanceToggleStudentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int studentId});
}

/// @nodoc
class __$$AttendanceToggleStudentImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceToggleStudentImpl>
    implements _$$AttendanceToggleStudentImplCopyWith<$Res> {
  __$$AttendanceToggleStudentImplCopyWithImpl(
    _$AttendanceToggleStudentImpl _value,
    $Res Function(_$AttendanceToggleStudentImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? studentId = null}) {
    return _then(
      _$AttendanceToggleStudentImpl(
        studentId: null == studentId
            ? _value.studentId
            : studentId // ignore: cast_nullable_to_non_nullable
                  as int,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceToggleStudentImpl implements AttendanceToggleStudent {
  const _$AttendanceToggleStudentImpl({required this.studentId});

  @override
  final int studentId;

  @override
  String toString() {
    return 'AttendanceEvent.toggleStudent(studentId: $studentId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceToggleStudentImpl &&
            (identical(other.studentId, studentId) ||
                other.studentId == studentId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, studentId);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceToggleStudentImplCopyWith<_$AttendanceToggleStudentImpl>
  get copyWith =>
      __$$AttendanceToggleStudentImplCopyWithImpl<
        _$AttendanceToggleStudentImpl
      >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return toggleStudent(studentId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return toggleStudent?.call(studentId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (toggleStudent != null) {
      return toggleStudent(studentId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return toggleStudent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return toggleStudent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (toggleStudent != null) {
      return toggleStudent(this);
    }
    return orElse();
  }
}

abstract class AttendanceToggleStudent implements AttendanceEvent {
  const factory AttendanceToggleStudent({required final int studentId}) =
      _$AttendanceToggleStudentImpl;

  int get studentId;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceToggleStudentImplCopyWith<_$AttendanceToggleStudentImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceSaveImplCopyWith<$Res> {
  factory _$$AttendanceSaveImplCopyWith(
    _$AttendanceSaveImpl value,
    $Res Function(_$AttendanceSaveImpl) then,
  ) = __$$AttendanceSaveImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceSaveImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceSaveImpl>
    implements _$$AttendanceSaveImplCopyWith<$Res> {
  __$$AttendanceSaveImplCopyWithImpl(
    _$AttendanceSaveImpl _value,
    $Res Function(_$AttendanceSaveImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceSaveImpl implements AttendanceSave {
  const _$AttendanceSaveImpl();

  @override
  String toString() {
    return 'AttendanceEvent.saveAttendance()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AttendanceSaveImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return saveAttendance();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return saveAttendance?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (saveAttendance != null) {
      return saveAttendance();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return saveAttendance(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return saveAttendance?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (saveAttendance != null) {
      return saveAttendance(this);
    }
    return orElse();
  }
}

abstract class AttendanceSave implements AttendanceEvent {
  const factory AttendanceSave() = _$AttendanceSaveImpl;
}

/// @nodoc
abstract class _$$AttendanceUpdateStatusImplCopyWith<$Res> {
  factory _$$AttendanceUpdateStatusImplCopyWith(
    _$AttendanceUpdateStatusImpl value,
    $Res Function(_$AttendanceUpdateStatusImpl) then,
  ) = __$$AttendanceUpdateStatusImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int attendanceId, String status});
}

/// @nodoc
class __$$AttendanceUpdateStatusImplCopyWithImpl<$Res>
    extends _$AttendanceEventCopyWithImpl<$Res, _$AttendanceUpdateStatusImpl>
    implements _$$AttendanceUpdateStatusImplCopyWith<$Res> {
  __$$AttendanceUpdateStatusImplCopyWithImpl(
    _$AttendanceUpdateStatusImpl _value,
    $Res Function(_$AttendanceUpdateStatusImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? attendanceId = null, Object? status = null}) {
    return _then(
      _$AttendanceUpdateStatusImpl(
        attendanceId: null == attendanceId
            ? _value.attendanceId
            : attendanceId // ignore: cast_nullable_to_non_nullable
                  as int,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceUpdateStatusImpl implements AttendanceUpdateStatus {
  const _$AttendanceUpdateStatusImpl({
    required this.attendanceId,
    required this.status,
  });

  @override
  final int attendanceId;
  @override
  final String status;

  @override
  String toString() {
    return 'AttendanceEvent.updateStatus(attendanceId: $attendanceId, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceUpdateStatusImpl &&
            (identical(other.attendanceId, attendanceId) ||
                other.attendanceId == attendanceId) &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, attendanceId, status);

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceUpdateStatusImplCopyWith<_$AttendanceUpdateStatusImpl>
  get copyWith =>
      __$$AttendanceUpdateStatusImplCopyWithImpl<_$AttendanceUpdateStatusImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadGroups,
    required TResult Function(Group group) selectGroup,
    required TResult Function(DateTime date) selectDate,
    required TResult Function(int groupId, DateTime date) loadForGroupAndDate,
    required TResult Function(int studentId) toggleStudent,
    required TResult Function() saveAttendance,
    required TResult Function(int attendanceId, String status) updateStatus,
  }) {
    return updateStatus(attendanceId, status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadGroups,
    TResult? Function(Group group)? selectGroup,
    TResult? Function(DateTime date)? selectDate,
    TResult? Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult? Function(int studentId)? toggleStudent,
    TResult? Function()? saveAttendance,
    TResult? Function(int attendanceId, String status)? updateStatus,
  }) {
    return updateStatus?.call(attendanceId, status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadGroups,
    TResult Function(Group group)? selectGroup,
    TResult Function(DateTime date)? selectDate,
    TResult Function(int groupId, DateTime date)? loadForGroupAndDate,
    TResult Function(int studentId)? toggleStudent,
    TResult Function()? saveAttendance,
    TResult Function(int attendanceId, String status)? updateStatus,
    required TResult orElse(),
  }) {
    if (updateStatus != null) {
      return updateStatus(attendanceId, status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceLoadGroups value) loadGroups,
    required TResult Function(AttendanceSelectGroup value) selectGroup,
    required TResult Function(AttendanceSelectDate value) selectDate,
    required TResult Function(AttendanceLoadForGroupAndDate value)
    loadForGroupAndDate,
    required TResult Function(AttendanceToggleStudent value) toggleStudent,
    required TResult Function(AttendanceSave value) saveAttendance,
    required TResult Function(AttendanceUpdateStatus value) updateStatus,
  }) {
    return updateStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceLoadGroups value)? loadGroups,
    TResult? Function(AttendanceSelectGroup value)? selectGroup,
    TResult? Function(AttendanceSelectDate value)? selectDate,
    TResult? Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult? Function(AttendanceToggleStudent value)? toggleStudent,
    TResult? Function(AttendanceSave value)? saveAttendance,
    TResult? Function(AttendanceUpdateStatus value)? updateStatus,
  }) {
    return updateStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceLoadGroups value)? loadGroups,
    TResult Function(AttendanceSelectGroup value)? selectGroup,
    TResult Function(AttendanceSelectDate value)? selectDate,
    TResult Function(AttendanceLoadForGroupAndDate value)? loadForGroupAndDate,
    TResult Function(AttendanceToggleStudent value)? toggleStudent,
    TResult Function(AttendanceSave value)? saveAttendance,
    TResult Function(AttendanceUpdateStatus value)? updateStatus,
    required TResult orElse(),
  }) {
    if (updateStatus != null) {
      return updateStatus(this);
    }
    return orElse();
  }
}

abstract class AttendanceUpdateStatus implements AttendanceEvent {
  const factory AttendanceUpdateStatus({
    required final int attendanceId,
    required final String status,
  }) = _$AttendanceUpdateStatusImpl;

  int get attendanceId;
  String get status;

  /// Create a copy of AttendanceEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceUpdateStatusImplCopyWith<_$AttendanceUpdateStatusImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AttendanceState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AttendanceStateCopyWith<$Res> {
  factory $AttendanceStateCopyWith(
    AttendanceState value,
    $Res Function(AttendanceState) then,
  ) = _$AttendanceStateCopyWithImpl<$Res, AttendanceState>;
}

/// @nodoc
class _$AttendanceStateCopyWithImpl<$Res, $Val extends AttendanceState>
    implements $AttendanceStateCopyWith<$Res> {
  _$AttendanceStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AttendanceInitialImplCopyWith<$Res> {
  factory _$$AttendanceInitialImplCopyWith(
    _$AttendanceInitialImpl value,
    $Res Function(_$AttendanceInitialImpl) then,
  ) = __$$AttendanceInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceInitialImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceInitialImpl>
    implements _$$AttendanceInitialImplCopyWith<$Res> {
  __$$AttendanceInitialImplCopyWithImpl(
    _$AttendanceInitialImpl _value,
    $Res Function(_$AttendanceInitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceInitialImpl implements AttendanceInitial {
  const _$AttendanceInitialImpl();

  @override
  String toString() {
    return 'AttendanceState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AttendanceInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class AttendanceInitial implements AttendanceState {
  const factory AttendanceInitial() = _$AttendanceInitialImpl;
}

/// @nodoc
abstract class _$$AttendanceLoadingImplCopyWith<$Res> {
  factory _$$AttendanceLoadingImplCopyWith(
    _$AttendanceLoadingImpl value,
    $Res Function(_$AttendanceLoadingImpl) then,
  ) = __$$AttendanceLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceLoadingImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceLoadingImpl>
    implements _$$AttendanceLoadingImplCopyWith<$Res> {
  __$$AttendanceLoadingImplCopyWithImpl(
    _$AttendanceLoadingImpl _value,
    $Res Function(_$AttendanceLoadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceLoadingImpl implements AttendanceLoading {
  const _$AttendanceLoadingImpl();

  @override
  String toString() {
    return 'AttendanceState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AttendanceLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class AttendanceLoading implements AttendanceState {
  const factory AttendanceLoading() = _$AttendanceLoadingImpl;
}

/// @nodoc
abstract class _$$AttendanceGroupsLoadedImplCopyWith<$Res> {
  factory _$$AttendanceGroupsLoadedImplCopyWith(
    _$AttendanceGroupsLoadedImpl value,
    $Res Function(_$AttendanceGroupsLoadedImpl) then,
  ) = __$$AttendanceGroupsLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Group> groups});
}

/// @nodoc
class __$$AttendanceGroupsLoadedImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceGroupsLoadedImpl>
    implements _$$AttendanceGroupsLoadedImplCopyWith<$Res> {
  __$$AttendanceGroupsLoadedImplCopyWithImpl(
    _$AttendanceGroupsLoadedImpl _value,
    $Res Function(_$AttendanceGroupsLoadedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? groups = null}) {
    return _then(
      _$AttendanceGroupsLoadedImpl(
        groups: null == groups
            ? _value._groups
            : groups // ignore: cast_nullable_to_non_nullable
                  as List<Group>,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceGroupsLoadedImpl implements AttendanceGroupsLoaded {
  const _$AttendanceGroupsLoadedImpl({required final List<Group> groups})
    : _groups = groups;

  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  @override
  String toString() {
    return 'AttendanceState.groupsLoaded(groups: $groups)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceGroupsLoadedImpl &&
            const DeepCollectionEquality().equals(other._groups, _groups));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_groups));

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceGroupsLoadedImplCopyWith<_$AttendanceGroupsLoadedImpl>
  get copyWith =>
      __$$AttendanceGroupsLoadedImplCopyWithImpl<_$AttendanceGroupsLoadedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return groupsLoaded(groups);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return groupsLoaded?.call(groups);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (groupsLoaded != null) {
      return groupsLoaded(groups);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return groupsLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return groupsLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (groupsLoaded != null) {
      return groupsLoaded(this);
    }
    return orElse();
  }
}

abstract class AttendanceGroupsLoaded implements AttendanceState {
  const factory AttendanceGroupsLoaded({required final List<Group> groups}) =
      _$AttendanceGroupsLoadedImpl;

  List<Group> get groups;

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceGroupsLoadedImplCopyWith<_$AttendanceGroupsLoadedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceReadyImplCopyWith<$Res> {
  factory _$$AttendanceReadyImplCopyWith(
    _$AttendanceReadyImpl value,
    $Res Function(_$AttendanceReadyImpl) then,
  ) = __$$AttendanceReadyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({
    List<Group> groups,
    Group selectedGroup,
    DateTime selectedDate,
    List<Student> students,
    List<Attendance> existingAttendance,
    Set<int> absentStudentIds,
    bool hasExistingAttendance,
  });

  $GroupCopyWith<$Res> get selectedGroup;
}

/// @nodoc
class __$$AttendanceReadyImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceReadyImpl>
    implements _$$AttendanceReadyImplCopyWith<$Res> {
  __$$AttendanceReadyImplCopyWithImpl(
    _$AttendanceReadyImpl _value,
    $Res Function(_$AttendanceReadyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groups = null,
    Object? selectedGroup = null,
    Object? selectedDate = null,
    Object? students = null,
    Object? existingAttendance = null,
    Object? absentStudentIds = null,
    Object? hasExistingAttendance = null,
  }) {
    return _then(
      _$AttendanceReadyImpl(
        groups: null == groups
            ? _value._groups
            : groups // ignore: cast_nullable_to_non_nullable
                  as List<Group>,
        selectedGroup: null == selectedGroup
            ? _value.selectedGroup
            : selectedGroup // ignore: cast_nullable_to_non_nullable
                  as Group,
        selectedDate: null == selectedDate
            ? _value.selectedDate
            : selectedDate // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        students: null == students
            ? _value._students
            : students // ignore: cast_nullable_to_non_nullable
                  as List<Student>,
        existingAttendance: null == existingAttendance
            ? _value._existingAttendance
            : existingAttendance // ignore: cast_nullable_to_non_nullable
                  as List<Attendance>,
        absentStudentIds: null == absentStudentIds
            ? _value._absentStudentIds
            : absentStudentIds // ignore: cast_nullable_to_non_nullable
                  as Set<int>,
        hasExistingAttendance: null == hasExistingAttendance
            ? _value.hasExistingAttendance
            : hasExistingAttendance // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GroupCopyWith<$Res> get selectedGroup {
    return $GroupCopyWith<$Res>(_value.selectedGroup, (value) {
      return _then(_value.copyWith(selectedGroup: value));
    });
  }
}

/// @nodoc

class _$AttendanceReadyImpl implements AttendanceReady {
  const _$AttendanceReadyImpl({
    required final List<Group> groups,
    required this.selectedGroup,
    required this.selectedDate,
    required final List<Student> students,
    required final List<Attendance> existingAttendance,
    required final Set<int> absentStudentIds,
    required this.hasExistingAttendance,
  }) : _groups = groups,
       _students = students,
       _existingAttendance = existingAttendance,
       _absentStudentIds = absentStudentIds;

  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  @override
  final Group selectedGroup;
  @override
  final DateTime selectedDate;
  final List<Student> _students;
  @override
  List<Student> get students {
    if (_students is EqualUnmodifiableListView) return _students;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_students);
  }

  final List<Attendance> _existingAttendance;
  @override
  List<Attendance> get existingAttendance {
    if (_existingAttendance is EqualUnmodifiableListView)
      return _existingAttendance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_existingAttendance);
  }

  final Set<int> _absentStudentIds;
  @override
  Set<int> get absentStudentIds {
    if (_absentStudentIds is EqualUnmodifiableSetView) return _absentStudentIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_absentStudentIds);
  }

  @override
  final bool hasExistingAttendance;

  @override
  String toString() {
    return 'AttendanceState.ready(groups: $groups, selectedGroup: $selectedGroup, selectedDate: $selectedDate, students: $students, existingAttendance: $existingAttendance, absentStudentIds: $absentStudentIds, hasExistingAttendance: $hasExistingAttendance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceReadyImpl &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            (identical(other.selectedGroup, selectedGroup) ||
                other.selectedGroup == selectedGroup) &&
            (identical(other.selectedDate, selectedDate) ||
                other.selectedDate == selectedDate) &&
            const DeepCollectionEquality().equals(other._students, _students) &&
            const DeepCollectionEquality().equals(
              other._existingAttendance,
              _existingAttendance,
            ) &&
            const DeepCollectionEquality().equals(
              other._absentStudentIds,
              _absentStudentIds,
            ) &&
            (identical(other.hasExistingAttendance, hasExistingAttendance) ||
                other.hasExistingAttendance == hasExistingAttendance));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    const DeepCollectionEquality().hash(_groups),
    selectedGroup,
    selectedDate,
    const DeepCollectionEquality().hash(_students),
    const DeepCollectionEquality().hash(_existingAttendance),
    const DeepCollectionEquality().hash(_absentStudentIds),
    hasExistingAttendance,
  );

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceReadyImplCopyWith<_$AttendanceReadyImpl> get copyWith =>
      __$$AttendanceReadyImplCopyWithImpl<_$AttendanceReadyImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return ready(
      groups,
      selectedGroup,
      selectedDate,
      students,
      existingAttendance,
      absentStudentIds,
      hasExistingAttendance,
    );
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return ready?.call(
      groups,
      selectedGroup,
      selectedDate,
      students,
      existingAttendance,
      absentStudentIds,
      hasExistingAttendance,
    );
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(
        groups,
        selectedGroup,
        selectedDate,
        students,
        existingAttendance,
        absentStudentIds,
        hasExistingAttendance,
      );
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return ready(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return ready?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(this);
    }
    return orElse();
  }
}

abstract class AttendanceReady implements AttendanceState {
  const factory AttendanceReady({
    required final List<Group> groups,
    required final Group selectedGroup,
    required final DateTime selectedDate,
    required final List<Student> students,
    required final List<Attendance> existingAttendance,
    required final Set<int> absentStudentIds,
    required final bool hasExistingAttendance,
  }) = _$AttendanceReadyImpl;

  List<Group> get groups;
  Group get selectedGroup;
  DateTime get selectedDate;
  List<Student> get students;
  List<Attendance> get existingAttendance;
  Set<int> get absentStudentIds;
  bool get hasExistingAttendance;

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceReadyImplCopyWith<_$AttendanceReadyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AttendanceSavingImplCopyWith<$Res> {
  factory _$$AttendanceSavingImplCopyWith(
    _$AttendanceSavingImpl value,
    $Res Function(_$AttendanceSavingImpl) then,
  ) = __$$AttendanceSavingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceSavingImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceSavingImpl>
    implements _$$AttendanceSavingImplCopyWith<$Res> {
  __$$AttendanceSavingImplCopyWithImpl(
    _$AttendanceSavingImpl _value,
    $Res Function(_$AttendanceSavingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceSavingImpl implements AttendanceSaving {
  const _$AttendanceSavingImpl();

  @override
  String toString() {
    return 'AttendanceState.saving()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AttendanceSavingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return saving();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return saving?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (saving != null) {
      return saving();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return saving(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return saving?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (saving != null) {
      return saving(this);
    }
    return orElse();
  }
}

abstract class AttendanceSaving implements AttendanceState {
  const factory AttendanceSaving() = _$AttendanceSavingImpl;
}

/// @nodoc
abstract class _$$AttendanceSavedImplCopyWith<$Res> {
  factory _$$AttendanceSavedImplCopyWith(
    _$AttendanceSavedImpl value,
    $Res Function(_$AttendanceSavedImpl) then,
  ) = __$$AttendanceSavedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AttendanceSavedImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceSavedImpl>
    implements _$$AttendanceSavedImplCopyWith<$Res> {
  __$$AttendanceSavedImplCopyWithImpl(
    _$AttendanceSavedImpl _value,
    $Res Function(_$AttendanceSavedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AttendanceSavedImpl implements AttendanceSaved {
  const _$AttendanceSavedImpl();

  @override
  String toString() {
    return 'AttendanceState.saved()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AttendanceSavedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return saved();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return saved?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return saved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return saved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(this);
    }
    return orElse();
  }
}

abstract class AttendanceSaved implements AttendanceState {
  const factory AttendanceSaved() = _$AttendanceSavedImpl;
}

/// @nodoc
abstract class _$$AttendanceErrorImplCopyWith<$Res> {
  factory _$$AttendanceErrorImplCopyWith(
    _$AttendanceErrorImpl value,
    $Res Function(_$AttendanceErrorImpl) then,
  ) = __$$AttendanceErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AttendanceErrorImplCopyWithImpl<$Res>
    extends _$AttendanceStateCopyWithImpl<$Res, _$AttendanceErrorImpl>
    implements _$$AttendanceErrorImplCopyWith<$Res> {
  __$$AttendanceErrorImplCopyWithImpl(
    _$AttendanceErrorImpl _value,
    $Res Function(_$AttendanceErrorImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? message = null}) {
    return _then(
      _$AttendanceErrorImpl(
        message: null == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$AttendanceErrorImpl implements AttendanceError {
  const _$AttendanceErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'AttendanceState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AttendanceErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AttendanceErrorImplCopyWith<_$AttendanceErrorImpl> get copyWith =>
      __$$AttendanceErrorImplCopyWithImpl<_$AttendanceErrorImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Group> groups) groupsLoaded,
    required TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )
    ready,
    required TResult Function() saving,
    required TResult Function() saved,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Group> groups)? groupsLoaded,
    TResult? Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult? Function()? saving,
    TResult? Function()? saved,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Group> groups)? groupsLoaded,
    TResult Function(
      List<Group> groups,
      Group selectedGroup,
      DateTime selectedDate,
      List<Student> students,
      List<Attendance> existingAttendance,
      Set<int> absentStudentIds,
      bool hasExistingAttendance,
    )?
    ready,
    TResult Function()? saving,
    TResult Function()? saved,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AttendanceInitial value) initial,
    required TResult Function(AttendanceLoading value) loading,
    required TResult Function(AttendanceGroupsLoaded value) groupsLoaded,
    required TResult Function(AttendanceReady value) ready,
    required TResult Function(AttendanceSaving value) saving,
    required TResult Function(AttendanceSaved value) saved,
    required TResult Function(AttendanceError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AttendanceInitial value)? initial,
    TResult? Function(AttendanceLoading value)? loading,
    TResult? Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult? Function(AttendanceReady value)? ready,
    TResult? Function(AttendanceSaving value)? saving,
    TResult? Function(AttendanceSaved value)? saved,
    TResult? Function(AttendanceError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AttendanceInitial value)? initial,
    TResult Function(AttendanceLoading value)? loading,
    TResult Function(AttendanceGroupsLoaded value)? groupsLoaded,
    TResult Function(AttendanceReady value)? ready,
    TResult Function(AttendanceSaving value)? saving,
    TResult Function(AttendanceSaved value)? saved,
    TResult Function(AttendanceError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class AttendanceError implements AttendanceState {
  const factory AttendanceError({required final String message}) =
      _$AttendanceErrorImpl;

  String get message;

  /// Create a copy of AttendanceState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AttendanceErrorImplCopyWith<_$AttendanceErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
